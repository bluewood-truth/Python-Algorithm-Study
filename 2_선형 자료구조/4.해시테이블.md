### 해시 테이블 (해시 맵)

* 키-값 형태의 자료구조로, 대부분의 연산의 시간 복잡도가 *O(1)*임.

#### 해시

* 해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말함. (SHA1 등)
* 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 해싱(Hashing)이라 하고, 이 기법 덕분에 정보를 빠르게 저장하고 검색할 수 있음.
* 좋은 해시 함수의 특징
  * 해시 함수 값의 충돌 최소화
  * 쉽고 빠른 연산
  * 해시 테이블 전체에 해시 값이 균일하게 분포함
  * 사용할 키의 모든 정보를 이용하여 해싱함
  * 해시 테이블 사용 효율이 높아야 함

* 로드 팩터: 해시 테이블에 저장된 데이터 수 n을 버킷의 수 k로 나눈 것. (*n/k*)
  * 로드 팩터 비율에 따라 해시 함수를 재작성할지, 해시 테이블의 크기를 조정할지를 결정함.
  * 일반적으로 로드 팩터가 증가할수록 해시 테이블 성능은 감소함.
*  충돌(Collision): 서로 다른 키의 해시 함수 값이 동일하게 나온 현상.
  * 개별 체이닝: 해시 충돌 시 같은 인덱스에 연결 리스트로 연결함.
  * 오픈 어드레싱: 해시 충돌 시 테이블에서 빈 공간을 탐사하여 저장함.
  * 파이썬은 오픈 어드레싱의 선형 탐사를 채용함. 로드 팩터가 낮을 때 선형 탐사는 체이닝보다 성능이 좋음. 그래서 파이썬은 해시 테이블 공간을 재할당할 로드 팩터를 0.66으로 비교적 낮게 잡음. (자바는 개별 체이닝 방식으로 로드 팩터는 0.75)

---

### Leetcode 771 - Jewels and Stones

* J는 보석이며 S는 갖고 있는 돌이다. S에는 보석이 몇 개나 있을까? 대소문자는 구분한다.

```python
# MY CODE - 32ms
# J를 집합으로 바꿔 검색을 빠르게 함
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        
        jewels = 0
        
        J = set(J)
        for s in S:
            if s in J:
                jewels += 1
                
        return jewels
```

```python
# 해시 테이블을 이용한 풀이 - 32ms
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        
        freqs = {}
        count = 0
        
        for s in S:
            if s not in freqs:
                freqs[s] = 1
            else:
                freqs[s] += 1
        
        for char in J:
            if char in freqs:
                count += freqs[char]
                
        return count
```

```python
# Counter를 이용한 풀이 - 32ms
# Counter 객체는 키가 없으면 0을 리턴하기 때문에 예외 처리가 필요 없다
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        
        freqs = collections.Counter(S)
        count = 0
        
        for char in J:
            count += freqs[char]
                
        return count
```

```python
# 파이썬다운 방식 - 28ms (네 방식 모두 속도는 동일하다 봐도 무방)
# s in J for s in S: S의 각 문자 s가 J에 포함되는지를 True/False 리스트로 반환한다
# 이를 sum하면 True의 갯수, 즉 보석의 갯수를 계산할 수 있다
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        return sum(s in J for s in S)
```